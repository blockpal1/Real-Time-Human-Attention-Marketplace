"use strict";
/**
 * Payment Router Client SDK
 *
 * Off-chain library for interacting with the Attention Marketplace Payment Router
 * on Solana. Provides helpers for wallet connection, escrow management, and settlement.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBatcher = exports.PaymentRouterClient = exports.USDC_MINT = exports.PAYMENT_ROUTER_PROGRAM_ID = void 0;
exports.findMarketConfigPDA = findMarketConfigPDA;
exports.findEscrowPDA = findEscrowPDA;
exports.findFeeVaultStatePDA = findFeeVaultStatePDA;
exports.findFeeVaultPDA = findFeeVaultPDA;
exports.findBuilderBalancePDA = findBuilderBalancePDA;
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
// Program ID (matches lib.rs declare_id!)
exports.PAYMENT_ROUTER_PROGRAM_ID = new web3_js_1.PublicKey("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");
// USDC Devnet Mint (example - replace with actual)
exports.USDC_MINT = new web3_js_1.PublicKey("4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU");
// --- PDA Derivations ---
function findMarketConfigPDA() {
    return web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("market_config")], exports.PAYMENT_ROUTER_PROGRAM_ID);
}
function findEscrowPDA(agentPubkey) {
    return web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("escrow"), agentPubkey.toBuffer()], exports.PAYMENT_ROUTER_PROGRAM_ID);
}
function findFeeVaultStatePDA() {
    return web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("fee_vault_state")], exports.PAYMENT_ROUTER_PROGRAM_ID);
}
function findFeeVaultPDA(feeVaultStatePDA) {
    return web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("fee_vault"), feeVaultStatePDA.toBuffer()], exports.PAYMENT_ROUTER_PROGRAM_ID);
}
function findBuilderBalancePDA(builderCode) {
    const builderCodeBytes = Buffer.alloc(32);
    const codeBuffer = Buffer.from(builderCode);
    if (codeBuffer.length <= 32) {
        codeBuffer.copy(builderCodeBytes);
    }
    return web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("builder"), builderCodeBytes], exports.PAYMENT_ROUTER_PROGRAM_ID);
}
;
// --- IDL placeholder (would be generated by anchor build) ---
// In production, import the generated IDL from target/idl/payment_router.json
// --- IDL placeholder (would be generated by anchor build) ---
// In production, import the generated IDL from target/idl/payment_router.json
const IDL_PLACEHOLDER = {
    version: "0.1.0",
    name: "payment_router",
    instructions: [],
    accounts: [],
};
// --- Main Client Class ---
class PaymentRouterClient {
    constructor(provider, idl) {
        this.provider = provider;
        this.connection = provider.connection;
        this.program = new anchor_1.Program(idl ?? IDL_PLACEHOLDER, exports.PAYMENT_ROUTER_PROGRAM_ID, provider);
    }
    // --- Initialize Market Config ---
    async initializeMarketConfig(admin, feeBasisPoints) {
        const [configPDA] = findMarketConfigPDA();
        const tx = await this.program.methods
            .initializeMarketConfig(feeBasisPoints)
            .accounts({
            admin: admin.publicKey,
            config: configPDA,
            systemProgram: web3_js_1.SystemProgram.programId,
        })
            .signers([admin])
            .rpc();
        return tx;
    }
    // --- Initialize Fee Vault (NEW) ---
    async initializeFeeVault(admin, mint) {
        const [feeVaultStatePDA] = findFeeVaultStatePDA();
        const [feeVaultPDA] = findFeeVaultPDA(feeVaultStatePDA);
        const tx = await this.program.methods
            .initializeFeeVault()
            .accounts({
            admin: admin.publicKey,
            feeVaultState: feeVaultStatePDA,
            feeVault: feeVaultPDA,
            mint: mint,
            systemProgram: web3_js_1.SystemProgram.programId,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
        })
            .signers([admin])
            .rpc();
        return tx;
    }
    // --- Deposit Escrow ---
    async depositEscrow(agent, amount, vaultAddress) {
        const [escrowPDA] = findEscrowPDA(agent.publicKey);
        const agentTokenAccount = await (0, spl_token_1.getAssociatedTokenAddress)(exports.USDC_MINT, agent.publicKey);
        const tx = await this.program.methods
            .depositEscrow(amount)
            .accounts({
            agent: agent.publicKey,
            agentTokenAccount: agentTokenAccount,
            escrowAccount: escrowPDA,
            vault: vaultAddress,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            systemProgram: web3_js_1.SystemProgram.programId,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
        })
            .signers([agent])
            .rpc();
        return tx;
    }
    // --- Close Settlement (Router-only) ---
    async closeSettlement(router, agentPubkey, userWallet, vaultAddress, verifiedSeconds, agreedPricePerSecond, nonce, builderCode = null) {
        const [escrowPDA] = findEscrowPDA(agentPubkey);
        const [configPDA] = findMarketConfigPDA();
        const [feeVaultStatePDA] = findFeeVaultStatePDA();
        const [feeVaultPDA] = findFeeVaultPDA(feeVaultStatePDA);
        let builderBalance = web3_js_1.SystemProgram.programId; // Default None
        if (builderCode) {
            const [pda] = findBuilderBalancePDA(builderCode);
            builderBalance = pda;
        }
        const tx = await this.program.methods
            .closeSettlement(verifiedSeconds, agreedPricePerSecond, nonce, builderCode)
            .accounts({
            router: router.publicKey,
            escrowAccount: escrowPDA,
            vault: vaultAddress,
            userWallet: userWallet,
            feeVaultState: feeVaultStatePDA,
            feeVault: feeVaultPDA,
            builderBalance: builderBalance,
            marketConfig: configPDA,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        })
            .signers([router])
            .rpc();
        return tx;
    }
    // --- Utility: Fetch Escrow Account ---
    async getEscrowAccount(agentPubkey) {
        const [escrowPDA] = findEscrowPDA(agentPubkey);
        try {
            const account = await this.program.account.escrowAccount.fetch(escrowPDA);
            return account;
        }
        catch {
            return null;
        }
    }
    // --- Utility: Fetch Market Config ---
    async getMarketConfig() {
        const [configPDA] = findMarketConfigPDA();
        try {
            const account = await this.program.account.marketConfig.fetch(configPDA);
            return account;
        }
        catch {
            return null;
        }
    }
}
exports.PaymentRouterClient = PaymentRouterClient;
// --- Transaction Batching for Sub-cent Fees ---
class TransactionBatcher {
    constructor(connection, payer) {
        this.pendingInstructions = [];
        this.connection = connection;
        this.payer = payer;
    }
    add(instruction) {
        this.pendingInstructions.push(instruction);
    }
    async flush() {
        if (this.pendingInstructions.length === 0)
            return [];
        const txSignatures = [];
        const MAX_IX_PER_TX = 10; // Conservative limit
        // Batch instructions into transactions
        for (let i = 0; i < this.pendingInstructions.length; i += MAX_IX_PER_TX) {
            const batch = this.pendingInstructions.slice(i, i + MAX_IX_PER_TX);
            const tx = new web3_js_1.Transaction();
            batch.forEach((ix) => tx.add(ix));
            const { blockhash } = await this.connection.getLatestBlockhash();
            tx.recentBlockhash = blockhash;
            tx.feePayer = this.payer.publicKey;
            tx.sign(this.payer);
            const sig = await this.connection.sendRawTransaction(tx.serialize());
            txSignatures.push(sig);
        }
        this.pendingInstructions = [];
        return txSignatures;
    }
    get pendingCount() {
        return this.pendingInstructions.length;
    }
}
exports.TransactionBatcher = TransactionBatcher;
// --- Export all ---
__exportStar(require("./security"), exports);
__exportStar(require("./bridge"), exports);
