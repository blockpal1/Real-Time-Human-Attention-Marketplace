/**
 * Payment Router Client SDK
 *
 * Off-chain library for interacting with the Attention Marketplace Payment Router
 * on Solana. Provides helpers for wallet connection, escrow management, and settlement.
 */

import {
    Program,
    AnchorProvider,
    Idl,
    BN,
    web3,
} from "@coral-xyz/anchor";
import {
    PublicKey,
    Keypair,
    Connection,
    Transaction,
    TransactionInstruction,
    SystemProgram,
    SYSVAR_RENT_PUBKEY,
} from "@solana/web3.js";
import {
    TOKEN_PROGRAM_ID,
    getAssociatedTokenAddress,
    createAssociatedTokenAccountInstruction,
} from "@solana/spl-token";

// Program ID (matches lib.rs declare_id!)
export const PAYMENT_ROUTER_PROGRAM_ID = new PublicKey(
    "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"
);

// USDC Devnet Mint (example - replace with actual)
export const USDC_MINT = new PublicKey(
    "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU"
);

// --- PDA Derivations ---

export function findMarketConfigPDA(): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
        [Buffer.from("market_config")],
        PAYMENT_ROUTER_PROGRAM_ID
    );
}

export function findEscrowPDA(agentPubkey: PublicKey): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
        [Buffer.from("escrow"), agentPubkey.toBuffer()],
        PAYMENT_ROUTER_PROGRAM_ID
    );
}

// --- IDL placeholder (would be generated by anchor build) ---
// In production, import the generated IDL from target/idl/payment_router.json
const IDL_PLACEHOLDER: Idl = {
    version: "0.1.0",
    name: "payment_router",
    instructions: [],
    accounts: [],
};

// --- Main Client Class ---

export class PaymentRouterClient {
    private program: Program;
    private provider: AnchorProvider;
    private connection: Connection;

    constructor(provider: AnchorProvider, idl?: Idl) {
        this.provider = provider;
        this.connection = provider.connection;
        this.program = new Program(
            idl ?? IDL_PLACEHOLDER,
            PAYMENT_ROUTER_PROGRAM_ID,
            provider
        );
    }

    // --- Initialize Market Config ---

    async initializeMarketConfig(
        admin: Keypair,
        feeBasisPoints: number
    ): Promise<string> {
        const [configPDA] = findMarketConfigPDA();

        const tx = await this.program.methods
            .initializeMarketConfig(feeBasisPoints)
            .accounts({
                admin: admin.publicKey,
                config: configPDA,
                systemProgram: SystemProgram.programId,
            })
            .signers([admin])
            .rpc();

        return tx;
    }

    // --- Deposit Escrow ---

    async depositEscrow(
        agent: Keypair,
        amount: BN,
        vaultAddress: PublicKey
    ): Promise<string> {
        const [escrowPDA] = findEscrowPDA(agent.publicKey);
        const agentTokenAccount = await getAssociatedTokenAddress(
            USDC_MINT,
            agent.publicKey
        );

        const tx = await this.program.methods
            .depositEscrow(amount)
            .accounts({
                agent: agent.publicKey,
                agentTokenAccount: agentTokenAccount,
                escrowAccount: escrowPDA,
                vault: vaultAddress,
                tokenProgram: TOKEN_PROGRAM_ID,
                systemProgram: SystemProgram.programId,
                rent: SYSVAR_RENT_PUBKEY,
            })
            .signers([agent])
            .rpc();

        return tx;
    }

    // --- Close Settlement (Router-only) ---

    async closeSettlement(
        router: Keypair,
        agentPubkey: PublicKey,
        userWallet: PublicKey,
        vaultAddress: PublicKey,
        verifiedSeconds: BN,
        agreedPricePerSecond: BN,
        nonce: BN
    ): Promise<string> {
        const [escrowPDA] = findEscrowPDA(agentPubkey);
        const [configPDA] = findMarketConfigPDA();

        const tx = await this.program.methods
            .closeSettlement(verifiedSeconds, agreedPricePerSecond, nonce)
            .accounts({
                router: router.publicKey,
                escrowAccount: escrowPDA,
                vault: vaultAddress,
                userWallet: userWallet,
                marketConfig: configPDA,
                tokenProgram: TOKEN_PROGRAM_ID,
            })
            .signers([router])
            .rpc();

        return tx;
    }

    // --- Utility: Fetch Escrow Account ---

    async getEscrowAccount(agentPubkey: PublicKey): Promise<{
        agent: PublicKey;
        balance: BN;
        bump: number;
    } | null> {
        const [escrowPDA] = findEscrowPDA(agentPubkey);
        try {
            const account = await this.program.account.escrowAccount.fetch(escrowPDA);
            return account as any;
        } catch {
            return null;
        }
    }

    // --- Utility: Fetch Market Config ---

    async getMarketConfig(): Promise<{
        authority: PublicKey;
        feeBasisPoints: number;
    } | null> {
        const [configPDA] = findMarketConfigPDA();
        try {
            const account = await this.program.account.marketConfig.fetch(configPDA);
            return account as any;
        } catch {
            return null;
        }
    }
}

// --- Transaction Batching for Sub-cent Fees ---

export class TransactionBatcher {
    private pendingInstructions: TransactionInstruction[] = [];
    private connection: Connection;
    private payer: Keypair;

    constructor(connection: Connection, payer: Keypair) {
        this.connection = connection;
        this.payer = payer;
    }

    add(instruction: TransactionInstruction): void {
        this.pendingInstructions.push(instruction);
    }

    async flush(): Promise<string[]> {
        if (this.pendingInstructions.length === 0) return [];

        const txSignatures: string[] = [];
        const MAX_IX_PER_TX = 10; // Conservative limit

        // Batch instructions into transactions
        for (let i = 0; i < this.pendingInstructions.length; i += MAX_IX_PER_TX) {
            const batch = this.pendingInstructions.slice(i, i + MAX_IX_PER_TX);
            const tx = new Transaction();
            batch.forEach((ix) => tx.add(ix));

            const { blockhash } = await this.connection.getLatestBlockhash();
            tx.recentBlockhash = blockhash;
            tx.feePayer = this.payer.publicKey;
            tx.sign(this.payer);

            const sig = await this.connection.sendRawTransaction(tx.serialize());
            txSignatures.push(sig);
        }

        this.pendingInstructions = [];
        return txSignatures;
    }

    get pendingCount(): number {
        return this.pendingInstructions.length;
    }
}

// --- Webhook Event Types ---

export interface SettlementEvent {
    type: "settlement";
    escrowAgent: string;
    userWallet: string;
    verifiedSeconds: number;
    agreedPricePerSecond: number;
    totalPayout: number;
    fee: number;
    netPayout: number;
    txSignature: string;
    timestamp: number;
}

export interface EscrowDepositEvent {
    type: "escrow_deposit";
    agent: string;
    amount: number;
    newBalance: number;
    txSignature: string;
    timestamp: number;
}

export type PaymentRouterEvent = SettlementEvent | EscrowDepositEvent;

// --- Export all ---

export * from "./security";
export * from "./bridge";
